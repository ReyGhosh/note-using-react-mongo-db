<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc4627 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml">
<!ENTITY rfc3986 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY rfc2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY rfc4287 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4287.xml">
<!ENTITY rfc2616 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml">
<!ENTITY rfc3339 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml">
<!ENTITY rfc2045 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml">
<!ENTITY rfc5226 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.5226.xml">
<!ENTITY rfc2396 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2396.xml">
<!ENTITY iddiscovery SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.hammer-discovery.xml">
<!ENTITY uritemplate SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.gregorio-uritemplate.xml">
<!ENTITY linkheader SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.nottingham-http-link-header.xml">
<!ENTITY html401 SYSTEM "http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-html401-19991224.xml">
<!ENTITY css21 SYSTEM "http://xml.resource.org/public/rfc/bibxml4/reference.W3C.CR-CSS21-20070719.xml">
]>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<rfc category="info" docName="draft-zyp-json-schema-03" ipr="trust200902">
	<front>
		<title abbrev="JSON Schema Media Type">A JSON Media Type for Describing the Structure and Meaning of JSON Documents</title>
		
		<author fullname="Kris Zyp" initials="K" role="editor" surname="Zyp">
			<organization>SitePen (USA)</organization>
			<address>
				<postal>
					<street>530 Lytton Avenue</street>
					<city>Palo Alto, CA 94301</city>
					<country>USA</country>
				</postal>
				<phone>+1 650 968 8787</phone>
				<email>kris@sitepen.com</email>
			</address>
		</author>
		
		<author fullname="Gary Court" initials="G" surname="Court">
			<address>
				<postal>
					<street></street>
					<city>Calgary, AB</city>
					<country>Canada</country>
				</postal>
				<email>gary.court@gmail.com</email>
			</address>
		</author>
		
		<date year="2011" />
		<workgroup>Internet Engineering Task Force</workgroup>
		<keyword>JSON</keyword>
		<keyword>Schema</keyword>
		<keyword>JavaScript</keyword>
		<keyword>Object</keyword>
		<keyword>Notation</keyword>
		<keyword>Hyper Schema</keyword>
		<keyword>Hypermedia</keyword>
		
		<abstract>
			<t>
				JSON (JavaScript Object Notation) Schema defines the media type "application/schema+json", 
				a JSON based format for defining 
				the structure of JSON data. JSON Schema provides a contract for what JSON 
				data is required for a given application and how to interact with it. JSON 
				Schema is intended to define validation, documentation, hyperlink 
				navigation, and interaction control of JSON data. 
			</t>
		</abstract>
	</front>
	
	<middle>
		<section title="Introduction">
			<t>
				JSON (JavaScript Object Notation) Schema is a JSON media type for defining 
				the structure of JSON data. JSON Schema provides a contract for what JSON 
				data is required for a given application and how to interact with it. JSON 
				Schema is intended to define validation, documentation, hyperlink 
				navigation, and interaction control of JSON data. 
			</t>
		</section>
		
		<section title="Conventions">
			<t>
				<!-- The text in this section has been copied from the official boilerplate, 
				and should not be modified.-->
				
				The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", 
				"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
				interpreted as described in <xref target="RFC2119">RFC 2119</xref>.
			</t>
		</section>
		
		<!-- ********************************************* -->
		
		<section title="Overview">
			<t>
				JSON Schema defines the media type "application/schema+json" for 
				describing the structure of other
				JSON documents. JSON Schema is JSON-based and includes facilities 
				for describing the structure of JSON documents in terms of
				allowable values, descriptions, and interpreting relations with other resources.
			</t>
			<t>
				JSON Schema format is organized into several separate definitions. The first 
				definition is the core schema specification. This definition is primary 
				concerned with describing a JSON structure and specifying valid elements
				in the structure. The second definition is the Hyper Schema specification
				which is intended define elements in a structure that can be interpreted as
				hyperlinks.
				Hyper Schema builds on JSON Schema to describe the hyperlink structure of 
				other JSON documents and elements of interaction. This allows user agents to be able to successfully navigate
				JSON documents based on their schemas.
			</t>
			<t>
				Cumulatively JSON Schema acts as a meta-document that can be used to define the required type and constraints on
				property values, as well as define the meaning of the property values
				for the purpose of describing a resource and determining hyperlinks
				within the representation. 
			</t>
			<figure>
				<preamble>An example JSON Schema that describes products might look like:</preamble>
				<artwork>
<![CDATA[	
{
	"title": "Product",
	"properties": {
		"id": {
			"type": "number",
			"description": "Product identifier",
			"required": true
		},
		"name": {
			"description": "Name of the product",
			"type": "string",
			"required": true
		},
		"price": {
			"required": true,
			"type": "number",
			"minimum": 0,
			"required": true
		},
		"tags": {
			"type": "array",
			"items": {
				"type": "string"
			}
		}
	},
	"links": [{
		"rel": "full",
		"href": "{id}"
	}, {
		"rel": "comments",
		"href": "comments/?id={id}"
	}]
}
]]>
				</artwork>
				<postamble>
					This schema defines the properties of the instance JSON documents, 
					the required properties (id, name, and price), as well as an optional
					property (tags). This also defines the link relations of the instance
					JSON documents.
				</postamble>
			</figure>
			
			<section title="Terminology">
				<t>
					For this specification, <spanx style="strong">schema</spanx> will be used to denote a JSON Schema 
					definition, and an <spanx style="strong">instance</spanx> refers to a JSON value that the schema 
					will be describing and validating.
				</t>
			</section>
			
			<section title="Design Considerations">
				<t>
					The JSON Schema media type does not attempt to dictate the structure of JSON
					representations that contain data, but rather provides a separate format
					for flexibly communicating how a JSON representation should be
					interpreted and validated, such that user agents can properly understand
					acceptable structures and extrapolate hyperlink information
					with the JSON document. It is acknowledged that JSON documents come
					in a variety of structures, and JSON is unique in that the structure
					of stored data structures often prescribes a non-ambiguous definite
					JSON representation. Attempting to force a specific structure is generally
					not viable, and therefore JSON Schema allows for a great flexibility
					in the structure of the JSON data that it describes.
				</t>
				<t>
					This specification is protocol agnostic.
					The underlying protocol (such as HTTP) should sufficiently define the
					semantics of the client-server interface, the retrieval of resource
					representations linked to by JSON representations, and modification of 
					those resources. The goal of this
					format is to sufficiently describe JSON structures such that one can
					utilize existing information available in existing JSON
					representations from a large variety of services that leverage a representational state transfer
					architecture using existing protocols.
				</t>
			</section>
		</section>
		
		<section title="Schema/Instance Association">
			<t>
				JSON Schema instances are correlated to their schema by the "describedby"
				relation, where the schema is defined to be the target of the relation.
				Instance representations may be of the "application/json" media type or
				any other subtype. Consequently, dictating how an instance
				representation should specify the relation to the schema is beyond the normative scope
				of this document (since this document specifically defines the JSON
				Schema media type, and no other), but it is recommended that instances
				specify their schema so that user agents can interpret the instance
				representation and messages may retain the self-descriptive
				characteristic, avoiding the need for out-of-band information about
				instance data. Two approaches are recommended for declaring the
				relation to the schema that describes the meaning of a JSON instance's (or collection 
				of instances) structure. A MIME type parameter named
				"profile" or a relation of "describedby" (which could be defined by a Link header) may be used:
				
				<figure>
					<artwork>
<![CDATA[	
Content-Type: application/my-media-type+json;
              profile=http://json.com/my-hyper-schema
]]>
					</artwork>
				</figure>
				
				or if the content is being transferred by a protocol (such as HTTP) that
				provides headers, a Link header can be used:
				
				<figure>
					<artwork>
<![CDATA[
Link: <http://json.com/my-hyper-schema>; rel="describedby"
]]>
					</artwork>
				</figure>
				
				Instances MAY specify multiple schemas, to indicate all the schemas that 
				are applicable to the data, and the data SHOULD be valid by all the schemas. 
				The instance data MAY have multiple schemas 
				that it is defined by (the instance data SHOULD be valid for those schemas). 
				Or if the document is a collection of instances, the collection MAY contain 
				instances from different schemas. When collections contain heterogeneous 
				instances, the "pathStart" attribute MAY be specified in the 
				schema to disambiguate which schema should be applied for each item in the 
				collection. However, ultimately, the mechanism for referencing a schema is up to the
				media type of the instance documents (if they choose to specify that schemas
				can be referenced).
			</t>
			
			<section title="Self-Descriptive Schema">
				<t>
					JSON Schemas can themselves be described using JSON Schemas. 
					A self-describing JSON Schema for the core JSON Schema can
					be found at <eref target="http://json-schema.org/schema">http://json-schema.org/schema</eref> for the latest version or 
					<eref target="http://json-schema.org/draft-03/schema">http://json-schema.org/draft-03/schema</eref> for the draft-03 version. The hyper schema 
					self-description can be found at <eref target="http://json-schema.org/hyper-schema">http://json-schema.org/hyper-schema</eref> 
					or <eref target="http://json-schema.org/draft-03/hyper-schema">http://json-schema.org/draft-03/hyper-schema</eref>. All schemas
					used within a protocol with media type definitions
					SHOULD include a MIME parameter that refers to the self-descriptive
					hyper schema or another schema that extends this hyper schema:
					
					<figure>
						<artwork>
<![CDATA[	
Content-Type: application/json; 
              profile=http://json-schema.org/draft-03/hyper-schema
]]>
						</artwork>
					</figure>
				</t>
			</section>
		</section>
		
		<section title="Core Schema Definition">
			<t>
				A JSON Schema is a JSON Object that defines various attributes 
				(including usage and valid values) of a JSON value. JSON
				Schema has recursive capabilities; there are a number of elements
				in the structure that allow for nested JSON Schemas.
			</t>
			
			<figure>
				<preamble>An example JSON Schema definition could look like:</preamble>
				<artwork>
<![CDATA[
{
	"description": "A person",
	"type": "object",

	"properties": {
		"name": {
			"type": "string"
		},
		"age": {
			"type": "integer",
			"maximum": 125
		}
	}
}
]]>
				</artwork>
			</figure>
			
			<t>
				A JSON Schema object may have any of the following properties, called schema
				attributes (all attributes are optional):
			</t>
			
			<section title="type">
				<t>
					This attribute defines what the primitive type or the schema of the instance MUST be in order to validate. 
					This attribute can take one of two forms:

					<list style="hanging">
						<t hangText="Simple Types">
							A string indicating a primitive or simple type. The following are acceptable string values:

							<list style="hanging">
								<t hangText="string">Value MUST be a string.</t>
								<t hangText="number">Value MUST be a number, floating point numbers are allowed. </t>
								<t hangText="integer">Value MUST be an integer, no floating point numbers are allowed. This is a subset of the number type.</t>
								<t hangText="boolean">Value MUST be a boolean. </t>
								<t hangText="object">Value MUST be an object.</t>
								<t hangText="array">Value MUST be an array.</t>
								<t hangText="null">Value MUST be null. Note this is mainly for purpose of being able use union types to define nullability. If this type is not included in a union, null values are not allowed (the primitives listed above do not allow nulls on their own).</t>
								<t hangText="any">Value MAY be of any type including null.</t>
							</list>
							
							If the property is not defined or is not in this list, then any type of value is acceptable. 
							Other type values MAY be used for custom purposes, but minimal validators of the specification 
							implementation can allow any instance value on unknown type values.
						</t>
						
						<t hangText="Union Types">
							An array of two or more simple type definitions. Each item in the array MUST be a simple type definition or a schema.
							The instance value is valid if it is of the same type as one of the simple type definitions, or valid by one of the schemas, in the array. 
						</t>
					</list>
				</t>
				
				<figure>
					<preamble>For example, a schema that defines if an instance can be a string or a number would be:</preamble>
					<artwork>
<![CDATA[
{
	"type": ["string", "number"]
}
]]></artwork>
				</figure>
			</section>
			
			<section title="properties" anchor="properties">
				<t>This attribute is an object with property definitions that define the valid values of instance object property values. When the instance value is an object, the property values of the instance object MUST conform to the property definitions in this object. In this object, each property definition's value MUST be a schema, and the property's name MUST be the name of the instance property that it defines. The instance property value MUST be valid according to the schema from the property definition. Properties are considered unordered, the order of the instance properties MAY be in any order.</t>
			</section>
			
			<section title="patternProperties">
				<t>This attribute is an object that defines the schema for a set of property names of an object instance. The name of each property of this attribute's object is a regular expression pattern in the ECMA 262/Perl 5 format, while the value is a schema. If the pattern matches the name of a property on the instance object, the value of the instance's property MUST be valid against the pattern name's schema value.</t>
			</section>
			
			<section title="additionalProperties" anchor="additionalProperties">
				<t>This attribute defines a schema for all properties that are not explicitly defined in an object type definition. If specified, the value MUST be a schema or a boolean. If false is provided, no additional properties are allowed beyond the properties defined in the schema. The default value is an empty schema which allows any value for additional properties.</t>
			</section>
			
			<section title="items">
				<t>This attribute defines the allowed items in an instance array, and MUST be a schema or an array of schemas. The default value is an empty schema which allows any value for items in the instance array.</t>
				<t>When this attribute value is a schema and the instance value is an array, then all the items in the array MUST be valid according to the schema.</t>
				<t>When this attribute value is an array of schemas and the instance value is an array, each position in the instance array MUST conform to the schema in the corresponding position for this array. This called tuple typing. When tuple typing is used, additional items are allowed, disallowed, or constrained by the <xref target="additionalItems">"additionalItems"</xref> attribute using the same rules as <xref target="additionalProperties">"additionalProperties"</xref> for objects.</t>
			</section>
			
			<section title="additionalItems" anchor="additionalItems">
				<t>This provides a definition for additional items in an array instance when tuple definitions of the items is provided. This can be false to indicate additional items in the array are not allowed, or it can be a schema that defines the schema of the additional items.</t>
			</section>
			
			<section title="required">
				<t>This attribute indicates if the instance must have a value, and not be undefined. This is false by default, making the instance optional.</t>
			</section>
			
			<section title="dependencies">
				<t>This attribute is an object that defines the requirements of a property on an instance object. If an object instance has a property with the same name as a property in this attribute's object, then the instance must be valid against the attribute's property value (hereafter referred to as the "dependency value").</t>
				<t>
					The dependency value can take one of two forms:
					
					<list style="hanging">
						<t hangText="Simple Dependency">
							If the dependency value is a string, then the instance object MUST have a property with the same name as the dependency value.
							If the dependency value is an array of strings, then the instance object MUST have a property with the same name as each string in the dependency value's array.
						</t>
						<t hangText="Schema Dependency">
							If the dependency value is a schema, then the instance object MUST be valid against the schema.
						</t>
					</list>
				</t>
			</section>
			
			<section title="minimum">
				<t>This attribute defines the minimum value of the instance property when the type of the instance value is a number.</t>
			</section>
			
			<section title="maximum">
				<t>This attribute defines the maximum value of the instance property when the type of the instance value is a number.</t>
			</section>
			
			<section title="exclusiveMinimum">
				<t>This attribute indicates if the value of the instance (if the instance is a number) can not equal the number defined by the "minimum" attribute. This is false by default, meaning the instance value can be greater then or equal to the minimum value.</t>
			</section>
			
			<section title="exclusiveMaximum">
				<t>This attribute indicates if the value of the instance (if the instance is a number) can not equal the number defined by the "maximum" attribute. This is false by default, meaning the instance value can be less then or equal to the maximum value.</t>
			</section>
			
			<section title="minItems">
				<t>This attribute defines the minimum number of values in an array when the array is the instance value.</t>
			</section>
			
			<section title="maxItems">
				<t>This attribute defines the maximum number of values in an array when the array is the instance value.</t>
			</section>
			
			<section title="uniqueItems" anchor="uniqueItems">
				<t>This attribute indicates that all items in an array instance MUST be unique (contains no two identical values).</t>
				<t>
					Two instance are consider equal if they are both of the same type and:
					
					<list>
						<t>are null; or</t>
						<t>are booleans/numbers/strings and have the same value; or</t>
						<t>are arrays, contains the same number of items, and each item in the array is equal to the corresponding item in the other array; or</t>
						<t>are objects, contains the same property names, and each property in the object is equal to the corresponding property in the other object.</t>
					</list>
				</t>
			</section>
			
			<section title="pattern">
				<t>When the instance value is a string, this provides a regular expression that a string instance MUST match in order to be valid. Regular expressions SHOULD follow the regular expression specification from ECMA 262/Perl 5</t>
			</section>
			
			<section title="minLength">
				<t>When the instance value is a string, this defines the minimum length of the string.</t>
			</section>
			
			<section title="maxLength">
				<t>When the instance value is a string, this defines the maximum length of the string.</t>
			</section>
			
			<section title="enum">
				<t>This provides an enumeration of all possible values that are valid for the instance property. This MUST be an array, and each item in the array represents a possible value for the instance value. If this attribute is defined, the instance value MUST be one of the values in the array in order for the schema to be valid. Comparison of enum values uses the same algorithm as defined in <xref target="uniqueItems">"uniqueItems"</xref>.</t>
			</section>
			
			<section title="default">
				<t>This attribute defines the default value of the instance when the instance is undefined.</t>
			</section>
			
			<section title="title">
				<t>This attribute is a string that provides a short description of the instance property.</t>
			</section>
			
			<section title="description">
				<t>This attribute is a string that provides a full description of the of purpose the instance property.</t>
			</section>
			
			<section title="format">
				<t>This property defines the type of data, content type, or microformat to be expected in the instance property values. A format attribute MAY be one of the values listed below, and if so, SHOULD adhere to the semantics describing for the format. A format SHOULD only be used to give meaning to primitive types (string, integer, number, or boolean). Validators MAY (but are not required to) validate that the instance values conform to a format.</t>
				
				<t>
					The following formats are predefined:
					
					<list style="hanging">
						<t hangText="date-time">This SHOULD be a date in ISO 8601 format of YYYY-MM-DDThh:mm:ssZ in UTC time. This is the recommended form of date/timestamp.</t>
						<t hangText="date">This SHOULD be a date in the format of YYYY-MM-DD. It is recommended that you use the "date-time" format instead of "date" unless you need to transfer only the date part.</t>
						<t hangText="time">This SHOULD be a time in the format of hh:mm:ss. It is recommended that you use the "date-time" format instead of "time" unless you need to transfer only the time part.</t>
						<t hangText="utc-millisec">This SHOULD be the difference, measured in milliseconds, between the specified time and midnight, 00:00 of January 1, 1970 UTC. The value SHOULD be a number (integer or float).</t>
						<t hangText="regex">A regular expression, following the regular expression specification from ECMA 262/Perl 5.</t>
						<t hangText="color">This is a CSS color (like "#FF0000" or "red"), based on <xref target="W3C.CR-CSS21-20070719">CSS 2.1</xref>.</t>
						<t hangText="style">This is a CSS style definition (like "color: red; background-color:#FFF"), based on <xref target="W3C.CR-CSS21-20070719">CSS 2.1</xref>.</t>
						<t hangText="phone">This SHOULD be a phone number (format MAY follow E.123).</t>
						<t hangText="uri">This value SHOULD be a URI.</t>
						<t hangText="email">This SHOULD be an email address.</t>
						<t hangText="ip-address">This SHOULD be an ip version 4 address.</t>
						<t hangText="ipv6">This SHOULD be an ip version 6 address.</t>
						<t hangText="host-name">This SHOULD be a host-name.</t>
					</list>
				</t>
				
				<t>Additional custom formats MAY be created. These custom formats MAY be expressed as an URI, and this URI MAY reference a schema of that format.</t>
			</section>
			
			<section title="divisibleBy">
				<t>This attribute defines what value the number instance must be divisible by with no remainder (the result of the division must be an integer.) The value of this attribute SHOULD NOT be 0.</t>
			</section>
			
			<section title="disallow">
				<t>This attribute takes the same values as the "type" attribute, however if the instance matches the type or if this value is an array and the instance matches any type or schema in the array, then this instance is not valid.</t>
			</section>
			
			<section title="extends">
				<t>The value of this property MUST be another schema which will provide a base schema which the current schema will inherit from. The inheritance rules are such that any instance that is valid according to the current schema MUST be valid according to the referenced schema. This MAY also be an array, in which case, the instance MUST be valid for all the schemas in the array. A schema that extends another schema MAY define additional attributes, constrain existing attributes, or add other constraints.</t>
				<t>
					Conceptually, the behavior of extends can be seen as validating an
					instance against all constraints in the extending schema as well as
					the extended schema(s). More optimized implementations that merge
					schemas are possible, but are not required. Some examples of using "extends":
					
					<figure>
						<artwork>
<![CDATA[
{
	"description": "An adult",
	"properties": {
		"age": {
			"minimum": 21
		}
	},
	"extends": {"$ref": "person"}
}
]]>
						</artwork>
					</figure>
					
					<figure>
						<artwork>
<![CDATA[
{
	"description": "Extended schema",
	"properties": {
		"deprecated": {
			"type": "boolean"
		}
	},
	"extends": {"$ref": "http://json-schema.org/draft-03/schema"}
}
]]>
						</artwork>
					</figure>
				</t>
			</section>
			
			<section title="id">
				<t>
					This attribute defines the current URI of this schema (this attribute is
					effectively a "self" link). This URI MAY be relative or absolute. If
					the URI is relative it is resolved against the current URI of the parent
					schema it is contained in. If this schema is not contained in any
					parent schema, the current URI of the parent schema is held to be the
					URI under which this schema was addressed. If id is missing, the current URI of a schema is
					defined to be that of the parent schema. The current URI of the schema
					is also used to construct relative references such as for $ref.
				</t>
			</section>
			
			<section title="$ref">
				<t>
					This attribute defines a URI of a schema that contains the full representation of this schema. 
					When a validator encounters this attribute, it SHOULD replace the current schema with the schema referenced by the value's URI (if known and available) and re-validate the instance. 
					This URI MAY be relative or absolute, and relative URIs SHOULD be resolved against the URI of the current schema.
				</t>
			</section>
			
			<section title="$schema">
				<t>
					This attribute defines a URI of a JSON Schema that is the schema of the current schema. 
					When this attribute is defined, a validator SHOULD use the schema referenced by the value's URI (if known and available) when resolving <xref target="hyper-schema">Hyper Schema</xref><xref target="links">links</xref>.
				</t>
				
				<t>
					A validator MAY use this attribute's value to determine which version of JSON Schema the current schema is written in, and provide the appropriate validation features and behavior. 
					Therefore, it is RECOMMENDED that all schema authors include this attribute in their schemas to prevent conflicts with future JSON Schema specification changes.
				</t>
			</section>
		</section>
		
		<section title="Hyper Schema" anchor="hyper-schema">
			<t>
				The following attributes are specified in addition to those
				attributes that already provided by the core schema with the specific
				purpose of informing user agents of relations between resources based
				on JSON data. Just as with JSON
				schema attributes, all the attributes in hyper schemas are optional.
				Therefore, an empty object is a valid (non-informative) schema, and
				essentially describes plain JSON (no constraints on the structures).
				Addition of attributes provides additive information for user agents.
			</t>
			
			<section title="links" anchor="links">
				<t>
					The value of the links property MUST be an array, where each item 
					in the array is a link description object which describes the link
					relations of the instances.
				</t>
				
				<section title="Link Description Object">
					<t>
						A link description object is used to describe link relations. In 
						the context of a schema, it defines the link relations of the 
						instances of the schema, and can be parameterized by the instance
						values. The link description format can be used on its own in
						regular (non-schema documents), and use of this format can
						be declared by referencing the normative link description
						schema as the the schema for the data structure that uses the 
						links. The URI of the normative link description schema is: 
						<eref target="http://json-schema.org/links">http://json-schema.org/links</eref> (latest version) or
						<eref target="http://json-schema.org/draft-03/links">http://json-schema.org/draft-03/links</eref> (draft-03 version).
					</t>
					
					<section title="href">
						<t>
							The value of the "href" link description property
							indicates the target URI of the related resource. The value
							of the instance property SHOULD be resolved as a URI-Reference per <xref target="RFC3986">RFC 3986</xref>
							and MAY be a relative URI. The base URI to be used for relative resolution
							SHOULD be the URI used to retrieve the instance object (not the schema)
							when used within a schema. Also, when links are used within a schema, the URI 
							SHOULD be parametrized by the property values of the instance 
							object, if property values exist for the corresponding variables
							in the template (otherwise they MAY be provided from alternate sources, like user input).
						</t>
						
						<t>
							Instance property values SHOULD be substituted into the URIs where
							matching braces ('{', '}') are found surrounding zero or more characters,
							creating an expanded URI. Instance property value substitutions are resolved
							by using the text between the braces to denote the property name
							from the instance to get the value to substitute. 
							
							<figure>
								<preamble>For example, if an href value is defined:</preamble>
								<artwork>
<![CDATA[
http://somesite.com/{id}
]]>
								</artwork>
								<postamble>Then it would be resolved by replace the value of the "id" property value from the instance object.</postamble>
							</figure>
							
							<figure>
								<preamble>If the value of the "id" property was "45", the expanded URI would be:</preamble>
								<artwork>
<![CDATA[
http://somesite.com/45
]]>
								</artwork>
							</figure>
							
							If matching braces are found with the string "@" (no quotes) between the braces, then the 
							actual instance value SHOULD be used to replace the braces, rather than a property value.
							This should only be used in situations where the instance is a scalar (string, 
							boolean